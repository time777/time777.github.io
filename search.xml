<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>顶级域名列表</title>
      <link href="/posts/1881.html"/>
      <url>/posts/1881.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>顶级域名列表有需要联系，会及时更新的。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>域名：ai-to-chat.com</p><p>域名简介：机器人、人工智能、智能AI、OpenAI、ChatGPT、Sora…</p><hr><p>域名：humancalm.com</p><p>域名简介：平静的人类、镇静的人类、机器人、人工智能、智能AI、ChatGPT …</p><hr><p>域名：dataurge.com</p><p>域名简介：数据推荐、数据挖掘、大数据、数据丛、数据仓库、大数据…</p><hr><p>域名：hnsjjt.com.cn</p><p>域名简介：河南数据集团、湖南数据集团、海南数据集团</p><hr><p>域名：hndatagroup.com</p><p>域名简介：河南数据集团、湖南数据集团、海南数据集团</p><hr><p>域名：hndatagroup.cn</p><p>域名简介：河南数据集团、湖南数据集团、海南数据集团</p><hr><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 域名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 腾讯云 </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> 域名 </tag>
            
            <tag> SEO </tag>
            
            <tag> 域名推广 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 击穿、穿透、雪崩产生原因以及解决思路</title>
      <link href="/posts/21747.html"/>
      <url>/posts/21747.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家都知道，计算机的瓶颈之一就是IO，为了解决内存与磁盘速度不匹配的问题，产生了缓存，将一些热点数据放在内存中，随用随取，降低连接到数据库的请求链接,避免数据库挂掉。需要注意的是，无论是击穿还是后面谈到的穿透与雪崩,都是在高并发前提下，比如当缓存中某一个热点key失效。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011111001.jpg"></p><h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>有两个主要原因：</p><p>1、Key过期；</p><p>2、Key被页面置换淘汰。</p><p>对于第一个原因是因为在Redis中，Key有过期时间，如果某一个时刻(假如商城做活动,零点开始)key失效，那么零点之后对某一个商品查询请求将全都压到数据库上，导致数据库崩。</p><p>对于第二个原因，因为内存是有限的，要时时刻刻缓存新的数据，淘汰旧的数据，所以在一定的页面置换策略(常见页面置换算法图解)中，淘汰数据，如果某些商品做活动之前无人问津，势必会被淘汰。</p><h3 id="应对击穿的处理思路"><a href="#应对击穿的处理思路" class="headerlink" title="应对击穿的处理思路"></a>应对击穿的处理思路</h3><p>正常的处理请求如图：<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011111002.jpg"></p><p>由于key过期在所难免，高流量来到Redis时,根据Redis的单线程特性，可以认为任务是在队列里依次执行的，当请求到达Redis发现Key过期时，进行一个操作：设置锁。</p><p>这个流程大概如下：</p><ul><li>请求到达Redis，发现Redis Key过期，查看有没有锁，没有锁的话回到队列后面排队</li><li>设置锁，注意，这儿应该是setnx()，而不是set()，因为可能有其他线程已经设置锁了</li><li>获取锁，拿到锁了就去数据库取数据，请求返回后释放锁。</li></ul><p><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011111003.jpg"></p><p>但是引出了一个新的问题，如果拿到锁去拿数据的请求然后挂了怎么办?也就是锁没有释放，其他进程都在等锁，解决办法是:</p><p><strong>对锁设置一个过期时间，如果到达了过期时间还没释放就自动释放，问题又来了，锁挂了好说，但是如果是锁超时呢?也就是在设定的时间里数据没有取出来，但是锁由过期了，常见的思路是，锁过期时间值递增，但是想想不靠谱，因为第一个请求可能超时，如果后面的也超时呢，接连多次超时之后，锁过期时间值势必特别大了，这样做弊端太多。</strong></p><p>另外一个思路是，再开启一个线程，进行监控，如果取数据的线程没有挂的话，就适当延迟锁的过期时间。</p><p><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011111004.jpg"></p><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><p>穿透主要原因是很多请求都在访问数据库不存在的数据，例如一个卖书的商城一直被请求查询茶叶产品，由于Redis缓存主要是用来缓存热点数据，对于数据库都不存在的数据,是没法缓存的，这种异常流量就会直接到达数据库并且返回”没有”的查询结果。</p><p>应对这种请求，处理办法是对访问请求加一层过滤器，例如布隆过滤器、增强版布隆过滤器、布谷鸟过滤器。</p><p><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011111005.jpg"></p><p>除了布隆过滤器，可以增加一些参数检验，例如数据库数据id一般都是递增的，如果请求 id = -10 这种参数，势必绕过Redis，避免这种情况，可以对用户真实性检验等操作。</p><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><p>雪崩，和击穿类似，不同的是击穿是一个热点Key某时刻失效，而雪崩是大量的热点Key在一瞬间失效，网络上很多博客都在强调解决雪崩的策略是随机过期时间，这个非常不准确，举个例子，银行做活动，之前这个利息系数为2%，过了零点系数改为3%，这种情况能将用户的对应的key改为随机过期吗？如果用的过去的数据叫脏数据。</p><p>明显不可以，同样存钱，你存到年底利息300万，隔壁才200万，这不得打架啊，开玩笑~</p><p>正确的思路是，首先要看看这个Key过期是不是时点性有关，时点性无关的话，可以随机过期时间解决。</p><p>如果是时点性有关，例如刚刚说的银行某一天改变某系数，那么就要利用强依赖击穿方案，策略是先过去的线程更新一下所有key。</p><p><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011111006.jpg"></p><p>在后台更新热点key的同时，业务层将进来的请求延时一下，例如短暂的睡几毫秒或者秒，给后面的更新热点key分散压力。</p><blockquote><p>转载自：<a href="https://mp.weixin.qq.com/s/cglhPxUJm6qZL-Yzr0aY1Q">https://mp.weixin.qq.com/s/cglhPxUJm6qZL-Yzr0aY1Q</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 击穿 </tag>
            
            <tag> 穿透 </tag>
            
            <tag> 雪崩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现发送邮件功能</title>
      <link href="/posts/8673.html"/>
      <url>/posts/8673.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文介绍邮件的常用基本协议，以及传统的JavaMail发送和新型的SpringBoot集成Mail发送。</p><h4 id="什么是-SMTP？"><a href="#什么是-SMTP？" class="headerlink" title="什么是 SMTP？"></a>什么是 SMTP？</h4><p>SMTP 全称为 Simple Mail Transfer Protocol（简单邮件传输协议），它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 认证要求必须提供账号和密码才能登陆服务器，其设计目的在于避免用户受到垃圾邮件的侵扰。</p><h4 id="什么是-IMAP？"><a href="#什么是-IMAP？" class="headerlink" title="什么是 IMAP？"></a>什么是 IMAP？</h4><p>IMAP 全称为 Internet Message Access Protocol（互联网邮件访问协议），IMAP 允许从邮件服务器上获取邮件的信息、下载邮件等。IMAP 与 POP 类似，都是一种邮件获取协议。</p><h4 id="什么是-POP3？"><a href="#什么是-POP3？" class="headerlink" title="什么是 POP3？"></a>什么是 POP3？</h4><p>POP3 全称为 Post Office Protocol 3（邮局协议），POP3 支持客户端远程管理服务器端的邮件。POP3 常用于 “离线” 邮件处理，即允许客户端下载服务器邮件，然后服务器上的邮件将会被删除。目前很多 POP3 的邮件服务器只提供下载邮件功能，服务器本身并不删除邮件，这种属于改进版的 POP3 协议。</p><h4 id="IMAP-和-POP3-协议有什么不同呢？"><a href="#IMAP-和-POP3-协议有什么不同呢？" class="headerlink" title="IMAP 和 POP3 协议有什么不同呢？"></a>IMAP 和 POP3 协议有什么不同呢？</h4><p>两者最大的区别在于，IMAP 允许双向通信，即在客户端的操作会反馈到服务器上，例如在客户端收取邮件、标记已读等操作，服务器会跟着同步这些操作。而对于 POP 协议虽然也允许客户端下载服务器邮件，但是在客户端的操作并不会同步到服务器上面的，例如在客户端收取或标记已读邮件，服务器不会同步这些操作。</p><h3 id="传统的JavaMail发送"><a href="#传统的JavaMail发送" class="headerlink" title="传统的JavaMail发送"></a>传统的JavaMail发送</h3><h4 id="什么是JavaMailSender和JavaMailSenderImpl？"><a href="#什么是JavaMailSender和JavaMailSenderImpl？" class="headerlink" title="什么是JavaMailSender和JavaMailSenderImpl？"></a>什么是JavaMailSender和JavaMailSenderImpl？</h4><p>JavaMailSender和JavaMailSenderImpl 是 Spring 官方提供的集成邮件服务的接口和实现类，以简单高效的设计著称，目前是 Java 后端发送邮件和集成邮件服务的主流工具。</p><h4 id="如何通过JavaMailSenderImpl发送邮件？"><a href="#如何通过JavaMailSenderImpl发送邮件？" class="headerlink" title="如何通过JavaMailSenderImpl发送邮件？"></a>如何通过JavaMailSenderImpl发送邮件？</h4><p>非常简单，直接在业务类注入JavaMailSenderImpl并调用send方法发送邮件。其中简单邮件可以通过SimpleMailMessage来发送邮件，而复杂的邮件（例如添加附件）可以借助MimeMessageHelper来构建MimeMessage发送邮件。例如：</p><pre><code>@Autowiredprivate JavaMailSenderImpl mailSender;public void sendMail() throws MessagingException {        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();        simpleMailMessage.setFrom("admin@163.com");        simpleMailMessage.setTo("socks@qq.com");        simpleMailMessage.setSubject("Happy New Year");        simpleMailMessage.setText("新年快乐！");        mailSender.send(simpleMailMessage);        MimeMessage mimeMessage = mailSender.createMimeMessage();        MimeMessageHelper messageHelper = new MimeMessageHelper(mimeMessage);        messageHelper.setFrom("admin@163.com");        messageHelper.setTo("socks@qq.com");        messageHelper.setSubject("Happy New Year");        messageHelper.setText("新年快乐！");        messageHelper.addInline("doge.gif", new File("xx/xx/doge.gif"));        messageHelper.addAttachment("work.docx", new File("xx/xx/work.docx"));        mailSender.send(mimeMessage);    }</code></pre><h4 id="为什么JavaMailSenderImpl-能够开箱即用-？"><a href="#为什么JavaMailSenderImpl-能够开箱即用-？" class="headerlink" title="为什么JavaMailSenderImpl 能够开箱即用 ？"></a>为什么JavaMailSenderImpl 能够开箱即用 ？</h4><p>所谓开箱即用其实就是基于官方内置的自动配置，翻看源码可知晓邮件自动配置类(MailSenderPropertiesConfiguration) 为上下文提供了邮件服务实例(JavaMailSenderImpl)。具体源码如下：</p><pre><code>@Configuration@ConditionalOnProperty(prefix = "spring.mail", name = "host")class MailSenderPropertiesConfiguration {private final MailProperties properties;    MailSenderPropertiesConfiguration(MailProperties properties) {this.properties = properties;    }@Bean@ConditionalOnMissingBeanpublic JavaMailSenderImpl mailSender() {        JavaMailSenderImpl sender = new JavaMailSenderImpl();        applyProperties(sender);return sender;    }</code></pre><p>其中MailProperties是关于邮件服务器的配置信息，具体源码如下：</p><pre><code>@ConfigurationProperties(prefix = "spring.mail")public class MailProperties {    private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;    private String host;    private Integer port;    private String username;    private String password;    private String protocol = "smtp";    private Charset defaultEncoding = DEFAULT_CHARSET;    private Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();}</code></pre><h2 id="新型的SpringBoot集成Mail发送"><a href="#新型的SpringBoot集成Mail发送" class="headerlink" title="新型的SpringBoot集成Mail发送"></a>新型的SpringBoot集成Mail发送</h2><h4 id="开启邮件服务-以163邮箱为例"><a href="#开启邮件服务-以163邮箱为例" class="headerlink" title="开启邮件服务 以163邮箱为例"></a>开启邮件服务 以163邮箱为例</h4><p>登陆网易邮箱 163，在设置中打开并勾选POP3/SMTP/IMAP服务，然后会得到一个授权码，这个邮箱和授权码将用作登陆认证。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011110401.jpg"></p><h4 id="配置邮件服务"><a href="#配置邮件服务" class="headerlink" title="配置邮件服务"></a>配置邮件服务</h4><p>首先咱们通过 Spring Initializr 创建工程springboot-send-mail，如图所示：<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011110402.jpg"></p><p>然后在pom.xml 引入web、thymeleaf 和spring-boot-starter-mail等相关依赖。例如：</p><pre><code>    &lt;dependencies&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.webjars&lt;/groupId&gt;        &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.webjars&lt;/groupId&gt;        &lt;artifactId&gt;jquery&lt;/artifactId&gt;        &lt;version&gt;3.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.webjars&lt;/groupId&gt;        &lt;artifactId&gt;bootstrap&lt;/artifactId&gt;        &lt;version&gt;3.3.7&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>根据前面提到的配置项(MailProperties)填写相关配置信息，其中spring.mail.username 表示连接邮件服务器时认证的登陆账号，可以是普通的手机号或者登陆账号，并非一定是邮箱，为了解决这个问题，推荐大家在spring.mail. properties.from填写邮件发信人即真实邮箱。</p><pre><code>spring:  mail:    host: smtp.163.com #SMTP服务器地址    username:  socks #登陆账号    password: 123456 #登陆密码（或授权码）    properties:      from: socks@163.com #邮件发信人（即真实邮箱）  thymeleaf:cache: false    prefix: classpath:/views/  servlet:    multipart:max-file-size: 10MB #限制单个文件大小max-request-size: 50MB #限制请求总量</code></pre><p>透过前面的进阶知识，我们知道在发送邮件前，需要先构建 SimpleMailMessage或 MimeMessage 邮件信息类来填写邮件标题、邮件内容等信息，最后提交给JavaMailSenderImpl发送邮件，这样看起来没什么问题，也能实现既定目标，但在实际使用中会出现大量零散和重复的代码，还不便于保存邮件到数据库。</p><p>那么优雅的发送邮件应该是如何的呢？应该屏蔽掉这些构建信息和发送邮件的细节，不管是简单还是复杂邮件，都可以通过统一的 API 来发送邮件。例如：mailService.send(mailVo) 。</p><p>例如通过邮件信息类 (MailVo) 来保存发送邮件时的邮件主题、邮件内容等信息 ：</p><pre><code>package com.hehe.vo;public class MailVo {    private String id;    private String from;    private String to;    private String subject;    private String text;    private Date sentDate;    private String cc;    private String bcc;    private String status;    private String error;    @JsonIgnore    private MultipartFile[] multipartFiles;}</code></pre><h4 id="发送邮件和附件"><a href="#发送邮件和附件" class="headerlink" title="发送邮件和附件"></a>发送邮件和附件</h4><blockquote><p>=========== 接下来正式介绍发送邮件的最核心逻辑 =============</p></blockquote><p>除了发送邮件之外，还包括检测邮件和保存邮件等操作，例如：</p><ul><li>检测邮件 checkMail(); 首先校验邮件收信人、邮件主题和邮件内容这些必填项，若为空则拒绝发送。</li><li>发送邮件 sendMimeMail(); 其次通过 MimeMessageHelper 来解析 MailVo 并构建 MimeMessage 传输邮件。</li><li>保存邮件 sendMimeMail(); 最后将邮件保存到数据库，便于统计和追查邮件问题。</li></ul><p>本案例邮件业务类 MailService 的具体源码如下：</p><pre><code>@Servicepublic class MailService {    private Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    private JavaMailSenderImpl mailSender;    public MailVo sendMail(MailVo mailVo) {        try {            checkMail(mailVo);            sendMimeMail(mailVo);            return saveMail(mailVo);        } catch (Exception e) {            logger.error("发送邮件失败:", e);            mailVo.setStatus("fail");            mailVo.setError(e.getMessage());            return mailVo;        }    }    private void checkMail(MailVo mailVo) {        if (StringUtils.isEmpty(mailVo.getTo())) {            throw new RuntimeException("邮件收信人不能为空");        }        if (StringUtils.isEmpty(mailVo.getSubject())) {            throw new RuntimeException("邮件主题不能为空");        }        if (StringUtils.isEmpty(mailVo.getText())) {            throw new RuntimeException("邮件内容不能为空");        }    }    private void sendMimeMail(MailVo mailVo) {        try {            MimeMessageHelper messageHelper = new MimeMessageHelper(mailSender.createMimeMessage(), true);            mailVo.setFrom(getMailSendFrom());            messageHelper.setFrom(mailVo.getFrom());            messageHelper.setTo(mailVo.getTo().split(","));            messageHelper.setSubject(mailVo.getSubject());            messageHelper.setText(mailVo.getText());            if (!StringUtils.isEmpty(mailVo.getCc())) {                messageHelper.setCc(mailVo.getCc().split(","));            }            if (!StringUtils.isEmpty(mailVo.getBcc())) {                messageHelper.setCc(mailVo.getBcc().split(","));            }            if (mailVo.getMultipartFiles() != null) {                for (MultipartFile multipartFile : mailVo.getMultipartFiles()) {                    messageHelper.addAttachment(multipartFile.getOriginalFilename(), multipartFile);                }            }            if (StringUtils.isEmpty(mailVo.getSentDate())) {                mailVo.setSentDate(new Date());                messageHelper.setSentDate(mailVo.getSentDate());            }            mailSender.send(messageHelper.getMimeMessage());            mailVo.setStatus("ok");            logger.info("发送邮件成功：{}-&gt;{}", mailVo.getFrom(), mailVo.getTo());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    private MailVo saveMail(MailVo mailVo) {        return mailVo;    }    public String getMailSendFrom() {        return mailSender.getJavaMailProperties().getProperty("from");    }}</code></pre><blockquote><p>搞定了发送邮件最核心的业务逻辑，接下来咱们写一个简单页面用来发送邮件。</p></blockquote><p>首先写好跟页面交互的控制器 MailController，具体源码如下：</p><pre><code>@RestControllerpublic class MailController {    @Autowired    private MailService mailService;    @GetMapping("/")    public ModelAndView index() {            ModelAndView mv = new ModelAndView("mail/sendMail");            mv.addObject("from", mailService.getMailSendFrom());    return mv;        }    @PostMapping("/mail/send")    public MailVo sendMail(MailVo mailVo, MultipartFile[] files) {            mailVo.setMultipartFiles(files);    return mailService.sendMail(mailVo);        }    }</code></pre><p>然后在/resources/views/mail目录新建sendMail.html，具体源码如下：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;&lt;meta charset="UTF-8"/&gt;&lt;title&gt;发送邮件&lt;/title&gt;&lt;link th:href="@{/webjars/bootstrap/css/bootstrap.min.css}" rel="stylesheet" type="text/css"/&gt;&lt;script th:src="@{/webjars/jquery/jquery.min.js}"&gt;&lt;/script&gt;&lt;script th:href="@{/webjars/bootstrap/js/bootstrap.min.js}"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;marquee behavior="alternate" onfinish="alert(12)"onMouseOut="this.start();$('#egg').text('嗯 真听话！');"onMouseOver="this.stop();$('#egg').text('有本事放开我呀！');"&gt;&lt;h5&gt;祝大家新年快乐！&lt;/h5&gt;&lt;img src="http://pics.sc.chinaz.com/Files/pic/faces/3709/7.gif" alt=""&gt;&lt;/marquee&gt;&lt;form&gt;&lt;div&gt;&lt;label&gt;邮件发信人:&lt;/label&gt;&lt;div&gt;&lt;input ${from}" readonly="readonly"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;label&gt;邮件收信人:&lt;/label&gt;&lt;div&gt;&lt;input &gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;label&gt;邮件主题:&lt;/label&gt;&lt;div&gt;&lt;input &gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;label&gt;邮件内容:&lt;/label&gt;&lt;div&gt;&lt;textarea &gt;&lt;/textarea&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;label&gt;邮件附件:&lt;/label&gt;&lt;div&gt;&lt;input &gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;label&gt;邮件操作:&lt;/label&gt;&lt;div&gt;&lt;a onclick="sendMail()"&gt;发送邮件&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;a onclick="clearForm()"&gt;清空&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/form&gt;&lt;script th:inline="javascript"&gt;        var appCtx = [[${#request.getContextPath()}]];        function sendMail() {            var formData = new FormData($('#mailForm')[0]);            $.ajax({                url: appCtx + '/mail/send',                type: "POST",                data: formData,                contentType: false,                processData: false,                success: function (result) {                    alert(result.status === 'ok' ? "发送成功！" : "你被Doge嘲讽了：" + result.error);                },                error: function () {                    alert("发送失败！");                }            });        }        function clearForm() {            $('#mailForm')[0].reset();        }        setInterval(function () {            var total = $('#mq').width();            var width = $('#doge').width();            var left = $('#doge').offset().left;            if (left &lt;= width / 2 + 20) {                $('#doge').css('transform', 'rotateY(180deg)')            }if (left &gt;= total - width / 2 - 40) {                $('#doge').css('transform', 'rotateY(-360deg)')            }        });&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="测试发送邮件"><a href="#测试发送邮件" class="headerlink" title="测试发送邮件"></a>测试发送邮件</h4><p>启动工程并访问：<a href="http://localhost:8080/">http://localhost:8080</a> 然后可以看到发送邮件的主界面如下：<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011110403.jpg"></p><p>然后填写你的小号邮箱，点击发送邮件，若成功则可以登陆小号邮箱查看邮件和刚才上传的附件。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2011110404.jpg"></p><h3 id="此项目的Github源码"><a href="#此项目的Github源码" class="headerlink" title="此项目的Github源码"></a>此项目的Github源码</h3><p>至此发送邮件代码全部完成，欢迎大家下载并关注 Github 源码。</p><blockquote><p>springboot-send-mail：<a href="https://github.com/yizhiwazi/springboot-socks">https://github.com/yizhiwazi/springboot-socks</a></p></blockquote><h3 id="常见失败编码"><a href="#常见失败编码" class="headerlink" title="常见失败编码"></a>常见失败编码</h3><blockquote><p>如果企业定制了邮件服务器，自然会记录邮件日志，根据错误编码存储日志有利于日常维护。</p></blockquote><p>例如这些由网易邮箱提供的错误编码标识：</p><ul><li><p>421<br>421 HL:REP 该 IP 发送行为异常，存在接收者大量不存在情况，被临时禁止连接。请检查是否有用户发送病毒或者垃圾邮件，并核对发送列表有效性；<br>421 HL:ICC 该 IP 同时并发连接数过大，超过了网易的限制，被临时禁止连接。请检查是否有用户发送病毒或者垃圾邮件，并降低 IP 并发连接数量；<br>421 HL:IFC 该 IP 短期内发送了大量信件，超过了网易的限制，被临时禁止连接。请检查是否有用户发送病毒或者垃圾邮件，并降低发送频率；<br>421 HL:MEP 该 IP 发送行为异常，存在大量伪造发送域域名行为，被临时禁止连接。请检查是否有用户发送病毒或者垃圾邮件，并使用真实有效的域名发送；</p></li><li><p>450<br>450 MI:CEL 发送方出现过多的错误指令。请检查发信程序；<br>450 MI:DMC 当前连接发送的邮件数量超出限制。请减少每次连接中投递的邮件数量；<br>450 MI:CCL 发送方发送超出正常的指令数量。请检查发信程序；<br>450 RP:DRC 当前连接发送的收件人数量超出限制。请控制每次连接投递的邮件数量；<br>450 RP:CCL 发送方发送超出正常的指令数量。请检查发信程序；<br>450 DT:RBL 发信 IP 位于一个或多个 RBL 里。请参考 <a href="http://www.rbls.org/">http://www.rbls.org/</a> 关于 RBL 的相关信息；<br>450 WM:BLI 该 IP 不在网易允许的发送地址列表里；<br>450 WM:BLU 此用户不在网易允许的发信用户列表里；</p></li><li><p>451<br>451 DT:SPM ,please try again 邮件正文带有垃圾邮件特征或发送环境缺乏规范性，被临时拒收。请保持邮件队列，两分钟后重投邮件。需调整邮件内容或优化发送环境；<br>451 Requested mail action not taken: too much fail authentication 登录失败次数过多，被临时禁止登录。请检查密码与帐号验证设置；<br>451 RP:CEL 发送方出现过多的错误指令。请检查发信程序；<br>451 MI:DMC 当前连接发送的邮件数量超出限制。请控制每次连接中投递的邮件数量；<br>451 MI:SFQ 发信人在 15 分钟内的发信数量超过限制，请控制发信频率；<br>451 RP:QRC 发信方短期内累计的收件人数量超过限制，该发件人被临时禁止发信。请降低该用户发信频率；<br>•451 Requested action aborted: local error in processing 系统暂时出现故障，请稍后再次尝试发送；</p></li><li><p>500<br>500 Error: bad syntaxU 发送的 smtp 命令语法有误；<br>550 MI:NHD HELO 命令不允许为空；<br>550 MI:IMF 发信人电子邮件地址不合规范。请参考 <a href="http://www.rfc-editor.org/">http://www.rfc-editor.org/</a> 关于电子邮件规范的定义；<br>550 MI:SPF 发信 IP 未被发送域的 SPF 许可。请参考 <a href="http://www.openspf.org/">http://www.openspf.org/</a> 关于 SPF 规范的定义；<br>550 MI:DMA 该邮件未被发信域的 DMARC 许可。请参考 <a href="http://dmarc.org/">http://dmarc.org/</a> 关于 DMARC 规范的定义；<br>550 MI:STC 发件人当天的连接数量超出了限定数量，当天不再接受该发件人的邮件。请控制连接次数；<br>550 RP:FRL 网易邮箱不开放匿名转发（Open relay）；<br>550 RP:RCL 群发收件人数量超过了限额，请减少每封邮件的收件人数量；<br>550 RP:TRC 发件人当天内累计的收件人数量超过限制，当天不再接受该发件人的邮件。请降低该用户发信频率；<br>550 DT:SPM 邮件正文带有很多垃圾邮件特征或发送环境缺乏规范性。需调整邮件内容或优化发送环境；<br>550 Invalid User 请求的用户不存在；<br>550 User in blacklist 该用户不被允许给网易用户发信；<br>550 User suspended 请求的用户处于禁用或者冻结状态；<br>550 Requested mail action not taken: too much recipient 群发数量超过了限额；</p></li><li><p>552<br>552 Illegal Attachment 不允许发送该类型的附件，包括以. uu .pif .scr .mim .hqx .bhx .cmd .vbs .bat .com .vbe .vb .js .wsh 等结尾的附件；<br>552 Requested mail action aborted: exceeded mailsize limit 发送的信件大小超过了网易邮箱允许接收的最大限制；</p></li><li><p>553<br>553 Requested action not taken: NULL sender is not allowed 不允许发件人为空，请使用真实发件人发送；<br>553 Requested action not taken: Local user only SMTP 类型的机器只允许发信人是本站用户；<br>553 Requested action not taken: no smtp MX only MX 类型的机器不允许发信人是本站用户；<br>553 authentication is required SMTP 需要身份验证，请检查客户端设置；</p></li><li><p>554<br>554 DT:SPM 发送的邮件内容包含了未被许可的信息，或被系统识别为垃圾邮件。请检查是否有用户发送病毒或者垃圾邮件；<br>554 DT:SUM 信封发件人和信头发件人不匹配；<br>554 IP is rejected, smtp auth error limit exceed 该 IP 验证失败次数过多，被临时禁止连接。请检查验证信息设置；<br>554 HL:IHU 发信 IP 因发送垃圾邮件或存在异常的连接行为，被暂时挂起。请检测发信 IP 在历史上的发信情况和发信程序是否存在异常；<br>554 HL:IPB 该 IP 不在网易允许的发送地址列表里；<br>554 MI:STC 发件人当天内累计邮件数量超过限制，当天不再接受该发件人的投信。请降低发信频率；<br>554 MI:SPB 此用户不在网易允许的发信用户列表里；<br>554 IP in blacklist 该 IP 不在网易允许的发送地址列表里。</p></li></ul><blockquote><p>转载自（个人根据使用经验修改）：<a href="https://mp.weixin.qq.com/s/a6Z0qzb4A-lPKiquTioRFQ">https://mp.weixin.qq.com/s/a6Z0qzb4A-lPKiquTioRFQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> JavaMail </tag>
            
            <tag> SpringBootMail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法说明</title>
      <link href="/posts/39284.html"/>
      <url>/posts/39284.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。</p><p>2、操作简单。比如编辑器编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题，要三个步骤。而Markdown只需要在标题内容前加#即可</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1、需要记一些语法（当然，是很简单，五分钟学会）。</p><p>2、有些平台不支持Markdown编辑模式。</p><h3 id="零、换行"><a href="#零、换行" class="headerlink" title="零、换行"></a>零、换行</h3><p>为了方便阅读，应该限制每行字符的数量，通常每行不超过 80 个字符。</p><blockquote><p>当超过 80 个字符后进行换行；</p></blockquote><blockquote><p>在一句话结束（。或！或？）之后回车空一行进行换行。</p></blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>在想要设置为标题的文字前面加#来表示</p><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><pre><code># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h3 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h3><ul><li>加粗</li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li>斜体</li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li>斜体加粗</li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li>删除线</li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><pre><code>**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre><p>效果如下：</p><p><strong>这是加粗的文字</strong></p><p><em>这是倾斜的文字</em></p><p><em><strong>这是斜体加粗的文字</strong></em></p><p><del>这是加删除线的文字</del></p><h3 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h3><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p><p>n个…</p><p>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><pre><code>&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</code></pre><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>三个或者三个以上的 - 或者 * 都可以。</p><h2 id="示例：-96-96-96"><a href="#示例：-96-96-96" class="headerlink" title="示例：```"></a>示例：<br>```</h2><hr><hr><hr><pre><code>效果如下：-------********### 五、图片语法：</code></pre><p>![图片alt](图片地址 ‘’图片title’’)<br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><pre><code>示例：</code></pre><p><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/background.jpg" alt="background" title="背景图片"></p><pre><code>效果如下：![background](https://myblog-1251991014.cos.ap-beijing.myqcloud.com/background.jpg "背景图片")### 六、超链接语法：</code></pre><p><a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="超链接title">超链接名</a><br>title可加可不加</p><pre><code>示例：</code></pre><p><a href="http://baidu.com/">百度</a><br><a href="http://jianshu.com/">简书</a></p><pre><code>效果如下：[百度](http://baidu.com)[简书](http://jianshu.com)注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</code></pre><p><a href="超链接地址" target="_blank">超链接名</a><br>示例<br><a href="https://www.jianshu.com/" target="_blank">简书</a></p><pre><code>### 七、列表#### 无序列表语法：无序列表用 - + * 任何一种都可以</code></pre><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容<br>注意：- + * 跟内容之间都要有一个空格</li></ul><pre><code>效果如下：- 列表内容+ 列表内容* 列表内容#### 有序列表语法：数字加点</code></pre><ol><li>列表内容</li><li>列表内容</li><li>列表内容<br>注意：序号跟内容之间要有空格</li></ol><pre><code>效果如下：1. 列表内容2. 列表内容3. 列表内容#### 列表嵌套上一级和下一级之间tab键即可语法：</code></pre><ul><li>一级无序列表内容 <ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li></ul><ol><li>一级无序列表内容 <ol><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ol></li></ol><pre><code>效果如下：- 一级无序列表内容    - 二级无序列表内容    - 二级无序列表内容    - 二级无序列表内容1. 一级无序列表内容    1. 二级无序列表内容    2. 二级无序列表内容    3. 二级无序列表内容### 八、表格语法：</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>第二行分割表头和内容。</p><ul><li>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</li></ul><pre><code>示例：</code></pre><table><thead><tr><th>姓名</th><th>排行</th></tr></thead><tbody><tr><td>刘备</td><td>二哥</td></tr><tr><td>关羽</td><td>二哥</td></tr><tr><td>张飞</td><td>三哥</td></tr></tbody></table><pre><code>效果如下：|  姓名   | 排行  ||  ----  | ----  || 刘备  | 大哥 || 关羽  | 二哥 || 张飞  | 三哥 |### 九、代码语法：单行代码：代码之间分别用一个反引号包起来</code></pre><p><code>代码内容</code></p><pre><code>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</code></pre><p>(<code>)   代码...   代码...   代码... (</code>)</p><pre><code>注 ：为了防止转译，前后三个反引号处加了小括号，实际是没有的，这里只是用来演示，实际中去掉两边小括号即可。示例：单行代码</code></pre><p><code>create database hero;</code></p><pre><code>代码块</code></pre><p>(<code>)     function fun(){          echo "这是一句非常牛逼的代码";     }     fun(); (</code>)</p><pre><code>效果如下：单行代码`create database hero;`代码块</code></pre><p>function fun(){<br>    echo “这是一句非常牛逼的代码”;<br>}<br>fun();</p><p>```</p><blockquote><p>参考连接：<br><a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a><br><a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐几款免费的图床网站</title>
      <link href="/posts/1388.html"/>
      <url>/posts/1388.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Markdown语法里面不支持直接上传图片，都是要用图片网络连接，故推荐几款收费/免费的图床网站</p><hr><h3 id="腾讯云对象存储COS"><a href="#腾讯云对象存储COS" class="headerlink" title="腾讯云对象存储COS"></a>腾讯云对象存储COS</h3><blockquote><p>地址：<a href="https://cloud.tencent.com/product/cos">https://cloud.tencent.com/product/cos</a></p></blockquote><h3 id="七牛云对象存储"><a href="#七牛云对象存储" class="headerlink" title="七牛云对象存储"></a>七牛云对象存储</h3><blockquote><p>地址：<a href="https://www.qiniu.com/products/kodo">https://www.qiniu.com/products/kodo</a></p></blockquote><h3 id="阿里云对象存储"><a href="#阿里云对象存储" class="headerlink" title="阿里云对象存储"></a>阿里云对象存储</h3><blockquote><p>地址：<a href="https://www.aliyun.com/product/oss">https://www.aliyun.com/product/oss</a></p></blockquote><h3 id="百度云对象存储"><a href="#百度云对象存储" class="headerlink" title="百度云对象存储"></a>百度云对象存储</h3><blockquote><p>地址：<a href="https://cloud.baidu.com/product/bos.html">https://cloud.baidu.com/product/bos.html</a></p></blockquote><h3 id="华为云对象存储"><a href="#华为云对象存储" class="headerlink" title="华为云对象存储"></a>华为云对象存储</h3><blockquote><p>地址：<a href="https://www.huaweicloud.com/product/obs.html">https://www.huaweicloud.com/product/obs.html</a></p></blockquote><hr><h3 id="MJJ-TODAY"><a href="#MJJ-TODAY" class="headerlink" title="MJJ.TODAY"></a>MJJ.TODAY</h3><blockquote><p>地址：<a href="https://mjj.today/">https://mjj.today/</a></p></blockquote><h3 id="Moetu"><a href="#Moetu" class="headerlink" title="Moetu"></a>Moetu</h3><blockquote><p>地址：<a href="https://moetu.org/">https://moetu.org/</a></p></blockquote><h3 id="盘络"><a href="#盘络" class="headerlink" title="盘络"></a>盘络</h3><blockquote><p>地址：<a href="https://pnglog.com/">https://pnglog.com/</a></p></blockquote><h3 id="ImgTP"><a href="#ImgTP" class="headerlink" title="ImgTP"></a>ImgTP</h3><blockquote><p>地址：<a href="https://imgtp.com/">https://imgtp.com/</a></p></blockquote><h3 id="ImgURL"><a href="#ImgURL" class="headerlink" title="ImgURL"></a>ImgURL</h3><blockquote><p>地址：<a href="https://www.imgurl.org/">https://www.imgurl.org/</a></p></blockquote><h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><blockquote><p>地址：<a href="https://7dtc.cn/">https://7dtc.cn/</a></p></blockquote><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><blockquote><p>地址：<a href="https://www.superbed.cn/">https://www.superbed.cn/</a></p></blockquote><h3 id="PostImage"><a href="#PostImage" class="headerlink" title="PostImage"></a>PostImage</h3><blockquote><p>地址：<a href="https://postimages.org/">https://postimages.org/</a></p></blockquote><h3 id="PICB-CC"><a href="#PICB-CC" class="headerlink" title="PICB.CC"></a>PICB.CC</h3><blockquote><p>地址：<a href="https://picb.cc/">https://picb.cc/</a></p></blockquote><h3 id="PZ"><a href="#PZ" class="headerlink" title="PZ"></a>PZ</h3><blockquote><p>地址：<a href="https://pz.al/">https://pz.al/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费图床 </tag>
            
            <tag> 腾讯云 </tag>
            
            <tag> 七牛云 </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> 百度云 </tag>
            
            <tag> 华为云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2.0实现单点登录的原理流程</title>
      <link href="/posts/10373.html"/>
      <url>/posts/10373.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>单点登录是多域名企业站点流行的登录方式。本文以现实生活场景辅助理解，力争彻底理清 OAuth2.0 实现单点登录的原理流程。同时总结了权限控制的实现方案，及其在微服务架构中的应用。</p><h3 id="1-什么是单点登录"><a href="#1-什么是单点登录" class="headerlink" title="1. 什么是单点登录"></a>1. 什么是单点登录</h3><h4 id="1-1-多点登录"><a href="#1-1-多点登录" class="headerlink" title="1.1 多点登录"></a>1.1 多点登录</h4><p>传统的多点登录系统中，每个站点都实现了本站专用的帐号数据库和登录模块。各站点的登录状态相互不认可，各站点需要逐一手工登录。如下图，有两个术语含义如下：</p><ul><li>认证(authentication): 验证用户的身份；</li><li>授权(authorization): 验证用户的访问权限。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/21.jpg"></li></ul><h4 id="1-1-单点登录"><a href="#1-1-单点登录" class="headerlink" title="1.1 单点登录"></a>1.1 单点登录</h4><p>单点登录，英文是 Single Sign On，缩写为 SSO。多个站点(192.168.1.20X)共用一台认证授权服务器(192.168.1.110，用户数据库和认证授权模块共用)。用户经由其中任何一个站点(比如 192.168.1.201)登录后，可以免登录访问其他所有站点。而且，各站点间可以通过该登录状态直接交互。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/22.jpg"></p><h3 id="2-OAuth2-认证授权的原理流程"><a href="#2-OAuth2-认证授权的原理流程" class="headerlink" title="2. OAuth2 认证授权的原理流程"></a>2. OAuth2 认证授权的原理流程</h3><h4 id="2-1-生活实例【★★重点★★】"><a href="#2-1-生活实例【★★重点★★】" class="headerlink" title="2.1 生活实例【★★重点★★】"></a>2.1 生活实例【★★重点★★】</h4><p>为了直观的理解 OAuth2.0 原理流程，我们假设这样一个生活场景：</p><p>(1)档案局A(客户端 / Client)：以“档案局ID/密码”标识，是掌握档案资源的机构。并列还有很多档案局B/C/…，每个档案局存储的档案内容(资源 / Resource)不一样，比如政治、经济、军事、文化等；</p><p>(2)公民张三(资源所有者 / Resource Owner)：以“用户名/密码”标识，需要到各个档案局查档案；</p><p>(3)派出所(授权服务器 / Authentication Server)：可以是单个巨大的派出所，也可以是数据共享的派出所集群，掌管的信息、提供的对外接口功能有：</p><p>档案局信息：所有档案局的“档案局ID/密码”，证明档案局的身份；</p><p>公民信息：所有公民的“用户名/密码”，能提供张三是张三的用户身份证明(认证 / Authentication)</p><p>公民对于档案局的权限：有张公民和档案局的权限的映射表，可查得各公民对各档案局是否有操作权限(授权 / Authorization)。通常，设计中会增加官职(角色 / Role)一层，各公民属于哪个官职(角色)，哪个官职(角色)对于特定档案局有操作权限。</p><h4 id="2-1-1-张三首次访问档案局A"><a href="#2-1-1-张三首次访问档案局A" class="headerlink" title="#2.1.1 张三首次访问档案局A"></a>#2.1.1 张三首次访问档案局A</h4><p>张三之前从未到访档案局，第一次来档案局。对照下图序号理解：</p><p>(1)张三来到“档案局A”的“档案处”，该处要求实名登记后才能查询，被指示到“用户登记处”办理(HTTP重定向)；</p><p>(2)张三来到“档案局A”的“用户登记处”，既不能证明身份(认证)，又不能证明自己有查档案A的权限(授权)。张三携带档案局A的标识(client-id)，被重定向至“授权信开具处”；</p><p>(3)张三来到“派出所”的“授权信开具处”，出示档案局A的标识，希望开具授权信(授权)。该处要求首先证明身份(认证)，被重定向至“用户身份验证处”；</p><p>(4)张三来到“派出所”的“用户身份验证处”，领取了用户身份表(网页登录表单 Form)；</p><p>(5)张三填上自己的用户名和密码，交给(提交 / Submit)“用户身份验证处”，该处从私用数据库中查得用户名密码匹配，确定此人是张三，开具身份证明信，完成 认证。张三带上身份证明信和档案局A的标识，被重定向至“授权信开具处”；</p><p>(6)张三再次来到“授权信开具处”，出示身份证明信和档案局A的标识，该处从私用数据库中查得，张三的官职是市长级别(角色)，该官职具有档案局A的查询权限，就开具“允许张三查询档案局A”的授权信(授权码 / code)，张三带上授权信被重定向至“档案局”的“用户登录处”；</p><p>(7)张三到了“档案局”的“用户登录处”，该处私下拿出档案局A的标识(client-id)和密码，再附上张三出示的授权信(code)，向“派出所”的“腰牌发放处”为张三申请的“腰牌”(token)，将来张三可以带着这个腰牌表明身份和权限。又被重定向到“档案处”；</p><p>(8)张三的会话(Session)已经关联上了腰牌(token)，可以直接通过“档案处”查档案。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/23.jpg"></p><h4 id="2-1-2-张三首次访问档案局B"><a href="#2-1-2-张三首次访问档案局B" class="headerlink" title="#2.1.2 张三首次访问档案局B"></a>#2.1.2 张三首次访问档案局B</h4><p>张三已经成功访问了档案局A，现在他要访问档案局B。对照下图序号理解：</p><p>(1)/(2) 同上；</p><p>(3)张三已经有“身份证明信”，直接在“派出所”的“授权信开具处”成功开具“访问档案局B”的授权信；</p><p>(4)/(5)/(6) 免了；</p><p>(7)“档案局B”的“用户登记处”完成登记；</p><p>(8)“档案局B”的“档案处”查得档案。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/24.jpg"></p><h4 id="2-1-3-张三再次访问档案局A"><a href="#2-1-3-张三再次访问档案局A" class="headerlink" title="#2.1.3 张三再次访问档案局A"></a>#2.1.3 张三再次访问档案局A</h4><p>张三已经成功访问了档案局A，现在他要访问档案局A。对照下图序号理解：</p><p>(1)直接成功查到了档案；</p><p>(2~8)都免了。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/25.jpg"></p><h4 id="2-2-HTTP-重定向原理"><a href="#2-2-HTTP-重定向原理" class="headerlink" title="2.2 HTTP 重定向原理"></a>2.2 HTTP 重定向原理</h4><p>HTTP 协议中，浏览器的 REQUEST 发给服务器之后，服务器如果发现该业务不属于自己管辖，会把你支派到自身服务器或其他服务器(host)的某个接口(uri)。正如我们去政府部门办事，每到一个窗口，工作人员会说“你带上材料A，到本所的X窗口，或者其他Y所的Z窗口”进行下一个手续。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/26.jpg"></p><h4 id="2-3-SSO-工作流程"><a href="#2-3-SSO-工作流程" class="headerlink" title="2.3 SSO 工作流程"></a>2.3 SSO 工作流程</h4><p>至此，就不难理解 OAuth 2.0 的认证/授权流程，此处不再赘述。请拿下图对照“2.1 生活实例”一节来理解。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/27.jpg"></p><h4 id="2-4-OAuth2-0-进阶"><a href="#2-4-OAuth2-0-进阶" class="headerlink" title="2.4 OAuth2.0 进阶"></a>2.4 OAuth2.0 进阶</h4><ul><li><a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749</a></li><li><a href="https://tools.ietf.org/html/rfc6750">https://tools.ietf.org/html/rfc6750</a></li><li><a href="https://blog.csdn.net/seccloud/article/details/8192707">https://blog.csdn.net/seccloud/article/details/8192707</a></li></ul><p>根据官方标准，OAuth 2.0 共用四种授权模式：</p><ul><li>Authorization Code: 用在服务端应用之间，这种最复杂，也是本文采用的模式；</li><li>Implicit: 用在移动app或者web app(这些app是在用户的设备上的，如在手机上调起微信来进行认证授权)</li><li>Resource Owner Password Credentials(password): 应用直接都是受信任的(都是由一家公司开发的，本例子使用)</li><li>Client Credentials: 用在应用API访问。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/28.jpg"></li></ul><h3 id="3-基于-SpringBoot-实现认证-x2F-授权"><a href="#3-基于-SpringBoot-实现认证-x2F-授权" class="headerlink" title="3. 基于 SpringBoot 实现认证/授权"></a>3. 基于 SpringBoot 实现认证/授权</h3><h4 id="3-1-授权服务器-Authorization-Server"><a href="#3-1-授权服务器-Authorization-Server" class="headerlink" title="3.1 授权服务器(Authorization Server)"></a>3.1 授权服务器(Authorization Server)</h4><p>(1) pom.xml</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>(2) application.properties</p><pre><code>server.port=8110 ## 监听端口</code></pre><p>(3) AuthorizationServerApplication.java</p><pre><code>@EnableResourceServer // 启用资源服务器public class AuthorizationServerApplication {// ...}</code></pre><p>(4) 配置授权服务的参数</p><pre><code>@Configuration@EnableAuthorizationServerpublic class Oauth2AuthorizationServerConfigurer extends AuthorizationServerConfigurerAdapter {    @Override    public void configure(final ClientDetailsServiceConfigurer clients) throws Exception {        clients.inMemory()                .withClient("webapp").secret("secret") //客户端 id/secret                .authorizedGrantTypes("authorization code") //授权妈模式                .scopes("user_info")                .autoApprove(true) //自动审批                .accessTokenValiditySeconds(3600); //有效期1hour    }}@Configurationpublic class Oauth2WebSecurityConfigurer extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        http.requestMatchers()        .antMatchers("/login", "/oauth/authorize/oauth/logout")        .and().authorizeRequests().anyRequest().authenticated()        .and().formLogin().permitAll();    }    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception {        auth.inMemoryAuthentication().withUser("admin").password("admin123").roles("ADMIN");    }}</code></pre><h4 id="3-2-客户端-Client-业务网站"><a href="#3-2-客户端-Client-业务网站" class="headerlink" title="3.2 客户端(Client, 业务网站)"></a>3.2 客户端(Client, 业务网站)</h4><p>(1) pom.xml</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>(2) application.properties</p><pre><code>server port=8080security.oauth2.client.client-id=webappsecurity.oauth2.client.client-secret=secretsecurity.oauth2.client.access-token-uri=http://localhost:8110/oauth/tokensecurity.oauth2.client.user-authorization-uri=http://localhost:8110/oauth/authorizesecurity.oauth2.resource.user-info-uri=http://localhost:8110/oauth/user</code></pre><p>(3) 配置 WEB 安全</p><pre><code>@Configuration@EnableOAuth2Ssopublic class Oauth2WebsecurityConfigurer extends WebSecurityConfigurerAdapter {    @Override    public void configure(HttpSecurity http) throws Exception {        http.antMatcher("/**").authorizeRequests()                .antMatchers("/", "/login").permitAll()                .anyRequest().authenticated();    }}@RestControllerpublic class Oauth2ClientController {    @GetMapping("/")    public ModelAndView index() {        return new ModelAndView("index");    }    @GetMapping("/welcome")    public ModelAndView welcome() {        return new ModelAndView("welcome");    }}</code></pre><h4 id="3-3-用户权限控制-基于角色"><a href="#3-3-用户权限控制-基于角色" class="headerlink" title="3.3 用户权限控制(基于角色)"></a>3.3 用户权限控制(基于角色)</h4><ul><li>授权服务器中，定义各用户拥有的角色: user=USER, admin=ADMIN/USER, root=ROOT/ADMIN/USER</li><li>业务网站中(client)，注解标明哪些角色可</li></ul><pre><code>@RestControllerpublic class Oauth2ClientController {    @GetMapping("/welcome")    public ModelAndView welcome() {        return new ModelAndView("welcome");    }    @GetMapping("/api/user")    @PreAuthorize("hasAuthority('USER')")    public Map&lt;String, Object&gt; apiUser() {    }    @GetMapping("/api/admin")    @PreAuthorize("hasAuthority('ADMIN')")    public Map&lt;String, Object&gt; apiAdmin() {    }    @GetMapping("/api/root")    @PreAuthorize("hasAuthority('ROOT')")    public Map&lt;String, Object&gt; apiRoot() {    }}</code></pre><h3 id="4-综合运用"><a href="#4-综合运用" class="headerlink" title="4. 综合运用"></a>4. 综合运用</h3><h4 id="4-1-权限控制方案"><a href="#4-1-权限控制方案" class="headerlink" title="4.1 权限控制方案"></a>4.1 权限控制方案</h4><p>下图是基本的认证/授权控制方案，主要设计了认证授权服务器上相关数据表的基本定义。可对照本文“2.1 生活实例”一节来理解。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/29.jpg"></p><h4 id="4-2-在微服务架构中的应用"><a href="#4-2-在微服务架构中的应用" class="headerlink" title="4.2 在微服务架构中的应用"></a>4.2 在微服务架构中的应用</h4><p>与常规服务架构不同，在微服务架构中，Authorization Server/Resource Server 是作为微服务存在的，用户的登录可以通过API网关一次性完成，无需与无法跳转至内网的 Authorization Server 来完成。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/30.jpg"></p><blockquote><p>转载自：<a href="https://mp.weixin.qq.com/s/LUz1H2Q26Ka0Kyho6Ly84w">https://mp.weixin.qq.com/s/LUz1H2Q26Ka0Kyho6Ly84w</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oauth2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Oauth2 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 单点登录 </tag>
            
            <tag> 授权认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度篇：RabbitMQ的5大问题详解</title>
      <link href="/posts/20169.html"/>
      <url>/posts/20169.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近，消息队列（Message Queue ，简称 MQ）越来越火。很多公司在用，很多人在用，其重要性不言而喻。<br>如果让你回答下面这些问题，你的心中是否有答案了呢？</p><ul><li>为什么要用 MQ？</li><li>引入 MQ 会多出哪些问题？</li><li>如何解决这些问题？</li></ul><p>本文将会一一为你解答，这些看似平常却很有意义的问题。</p><h3 id="1-传统模式有哪些痛点"><a href="#1-传统模式有哪些痛点" class="headerlink" title="1. 传统模式有哪些痛点"></a>1. 传统模式有哪些痛点</h3><h4 id="痛点-1"><a href="#痛点-1" class="headerlink" title="痛点 1"></a>痛点 1</h4><p>有些复杂的业务系统，一次用户请求可能会同步调用 N 个系统的接口，需要等待所有的接口都返回才能真正的获取执行结果。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/1.jpg"><br>这种同步接口调用的方式总耗时比较长，非常影响用户体验。特别是在网络不稳定的情况下，极容易出现接口超时问题。</p><h4 id="痛点-2"><a href="#痛点-2" class="headerlink" title="痛点 2"></a>痛点 2</h4><p>很多复杂的业务系统，一般都会拆分成多个子系统。以用户下单为例，请求会先通过订单系统，然后分别调用支付系统、库存系统、积分系统和物流系统。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/2.jpg"><br>系统之间耦合性太高，如果调用的任何一个子系统出现异常，整个请求都会异常。对系统的稳定性非常不利。</p><h4 id="痛点-3"><a href="#痛点-3" class="headerlink" title="痛点 3"></a>痛点 3</h4><p>为了吸引用户，有时候会搞一些活动，比如秒杀等。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/3.jpg"><br>如果用户少还好，不会影响系统的稳定性。但如果用户突增，一时间所有的请求都到数据库，可能会导致数据库无法承受这么大的压力，响应变慢或者直接挂掉。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/4.jpg"><br>对于这种突然出现的请求峰值，无法保证系统的稳定性。</p><h3 id="2-为什么要用-MQ"><a href="#2-为什么要用-MQ" class="headerlink" title="2. 为什么要用 MQ"></a>2. 为什么要用 MQ</h3><p>对于上面传统模式的三类问题，使用 MQ 就能轻松解决。</p><h4 id="2-1-异步"><a href="#2-1-异步" class="headerlink" title="2.1 异步"></a>2.1 异步</h4><p>对于痛点 1 同步接口调用导致响应时间长的问题。使用 MQ 之后，将同步调用改成异步调用，能够显著减少系统响应时间。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/5.jpg"><br>系统 A 作为消息的生产者，在完成本职工作后就能直接返回结果了。无需等待消息消费者的返回，它们最终会独立完成所有的业务功能。</p><p>这样能避免总耗时比较长，从而影响用户的体验的问题。</p><h4 id="2-2-解耦"><a href="#2-2-解耦" class="headerlink" title="2.2 解耦"></a>2.2 解耦</h4><p>对于痛点 2 子系统间耦合性太大的问题，使用 MQ 之后，只需要依赖于 MQ。避免了各个子系统间的强依赖问题。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/6.jpg"><br>订单系统作为消息生产者，保证它自己没有异常即可，不会受到支付系统等业务子系统的异常影响。并且各个消费者业务子系统之间，也互不影响。</p><p>这样就把之前复杂的业务子系统的依赖关系，转换为只依赖于 MQ 的简单依赖，从而显著的降低了系统间的耦合度。</p><h4 id="2-3-削峰"><a href="#2-3-削峰" class="headerlink" title="2.3 削峰"></a>2.3 削峰</h4><p>对于痛点 3，由于突然出现的请求峰值导致系统不稳定的问题。使用 MQ 后，能够起到削峰的作用。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/7.jpg"><br>订单系统接收到用户请求之后，将请求直接发送到 MQ；</p><p>然后，订单消费者从 MQ 中消费消息，做写库操作；</p><p>当出现请求峰值的情况，由于消费者的消费能力有限，会按照自己的节奏来消费消息。多余请求不处理，保留在 MQ 的队列中，不会对系统的稳定性造成影响。</p><h3 id="3-引入-MQ-会多出哪些问题"><a href="#3-引入-MQ-会多出哪些问题" class="headerlink" title="3. 引入 MQ 会多出哪些问题"></a>3. 引入 MQ 会多出哪些问题</h3><p>引入 MQ 后让子系统间耦合性降低了，异步处理机制减少了系统的响应时间。同时能够有效的应对请求峰值问题，提升了系统的稳定性。<br>但是，引入 MQ 的同时也会带来一些问题。</p><h4 id="3-1-重复消费问题"><a href="#3-1-重复消费问题" class="headerlink" title="3.1 重复消费问题"></a>3.1 重复消费问题</h4><p>重复消费问题可以说是 MQ 中普遍存在的问题，不管你用哪种 MQ 都无法避免。</p><p>有哪些场景会出现重复的消息呢？</p><p>消息生产者产生了重复的消息；<br>Kafka 和 RocketMQ 的 offset 被回调了；<br>消息消费者确认失败；<br>消息消费者确认时超时；<br>业务系统主动发起重试。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/8.jpg"><br>如果重复消息不做正确的处理，会对业务造成很大的影响，产生重复数据或者导致数据异常，比如会员系统多开通了一个月的会员等。</p><h4 id="3-2-数据一致性问题"><a href="#3-2-数据一致性问题" class="headerlink" title="3.2 数据一致性问题"></a>3.2 数据一致性问题</h4><p>很多时候，如果 MQ 的消费者业务处理异常，就会出现数据一致性问题。</p><p>举个例子，一个完整的业务流程是，下单成功之后送 100 个积分。下单写库成功了，但是消息消费者在送积分的时候失败了。这样就会造成数据不一致的情况，即该业务流程的部分数据写库了，另外一部分没有写库。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/9.jpg"><br>如果下单和送积分在同一个事务中，要么同时成功，要么同时失败。这样不会出现数据一致性问题的。</p><p>但由于跨系统调用，为了性能考虑一般不会使用强一致性的方案，而改成达成最终一致性即可。</p><h4 id="3-3-消息丢失问题"><a href="#3-3-消息丢失问题" class="headerlink" title="3.3 消息丢失问题"></a>3.3 消息丢失问题</h4><p>同样消息丢失问题，也是 MQ 中普遍存在的问题，不管你用哪种 MQ 都无法避免。</p><p>有哪些场景会出现消息丢失问题呢？</p><p>生产者产生消息时，由于网络原因发送到 MQ 失败了；<br>MQ 服务器持久化，存储磁盘时出现异常；<br>Kafka 和 RocketMQ 的 offset 被回调时，略过了很多消息；<br>消费者刚读取消息，已经 ACK 确认，但业务还没处理完，服务就被重启了。</p><p>导致消息丢失问题的原因挺多的，生产者、MQ 服务器、消费者都有可能产生问题。我在这里就不一一列举了。</p><p>最终的结果会导致消费者无法正确的处理消息，而导致数据不一致的情况。</p><h4 id="3-4-消息顺序问题"><a href="#3-4-消息顺序问题" class="headerlink" title="3.4 消息顺序问题"></a>3.4 消息顺序问题</h4><p>有些业务数据是有状态的，比如订单有下单、支付、完成、退货等状态。如果订单数据作为消息体，就会涉及顺序问题了。</p><p>例如消费者收到同一个订单的两条消息。第一条消息的状态是下单，第二条消息的状态是支付，这是没问题的。</p><p>但如果第一条消息的状态是支付，第二条消息的状态是下单就会有问题了。没有下单就先支付了？<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/10.png"><br>消息顺序问题是一个非常棘手的问题，比如：</p><p>Kafka 同一个 partition 中能保证顺序，但是不同的 partition 无法保证顺序；<br>RabbitMQ的同一个 queue 能够保证顺序，但是如果多个消费者同一个 queue 也会有顺序问题。</p><p>如果消费者使用多线程消费消息，也无法保证顺序。</p><p>如果消费消息时同一个订单的多条消息中，中间的一条消息出现异常情况，顺序将会被打乱。</p><p>还有如果生产者发送到 MQ 中的路由规则，跟消费者不一样，也无法保证顺序。</p><h4 id="3-5-消息堆积"><a href="#3-5-消息堆积" class="headerlink" title="3.5 消息堆积"></a>3.5 消息堆积</h4><p>如果消息消费者读取消息的速度，能够跟上消息生产者的节奏，那么整套 MQ 机制就能发挥最大作用。</p><p>但是很多时候，由于某些批处理或者其他原因，导致消费速度小于生产速度。这样会直接导致消息堆积问题，从而影响业务功能。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/11.jpg"><br>这里以下单开通会员为例，如果消息出现堆积会导致用户下单之后，很久之后才能变成会员。这种情况肯定会引起大量用户投诉。</p><h4 id="3-6-系统复杂度提升"><a href="#3-6-系统复杂度提升" class="headerlink" title="3.6 系统复杂度提升"></a>3.6 系统复杂度提升</h4><p>这里说的系统复杂度和系统耦合性是不一样的。</p><p>假设以前只有系统 A、系统 B 和系统 C 三个系统，引入 MQ 之后，除了需要关注前面三个系统之外，还需要关注 MQ 服务。需要关注的点越多，系统的复杂度越高。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/12.jpg"><br>MQ 的机制需要生产者、MQ 服务器、消费者。有一定的学习成本，需要额外部署 MQ 服务器。</p><p>有些 MQ 功能非常强大、用法有点复杂，例如 RocketMQ。如果使用不好，会出现很多问题。有些问题，不像接口调用那么容易排查，从而导致系统的复杂度提升了。</p><h3 id="4-如何解决这些问题？"><a href="#4-如何解决这些问题？" class="headerlink" title="4. 如何解决这些问题？"></a>4. 如何解决这些问题？</h3><p>MQ 是一种趋势，总体来说对我们的系统是利大于弊的，难道因为它会出现一些问题，我们就不用它了？那么我们要如何解决这些问题呢？</p><h4 id="4-1-重复消息问题"><a href="#4-1-重复消息问题" class="headerlink" title="4.1 重复消息问题"></a>4.1 重复消息问题</h4><p>不管是由于生产者产生的重复消息，还是由于消费者导致的重复消息，我们都可以在消费者中解决这个问题。</p><p>这就要求消费者在做业务处理时，要做幂等设计。如果有不知道如何设计的朋友，可以参考“高并发下如何保证接口的幂等性？”，里面介绍得非常详细。</p><p>在这里我推荐增加一张消费消息表，来解决 MQ 的这类问题。</p><p>消费消息表中，使用 messageId 做唯一索引。在处理业务逻辑之前，先根据 messageId 查询一下该消息有没有处理过。如果已经处理过了则直接返回成功，如果没有处理过，则继续做业务处理。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/13.jpg"></p><h4 id="4-2-数据一致性问题"><a href="#4-2-数据一致性问题" class="headerlink" title="4.2 数据一致性问题"></a>4.2 数据一致性问题</h4><p>我们都知道数据一致性分为：</p><p>强一致性<br>弱一致性<br>最终一致性</p><p>而 MQ 为了性能考虑使用的是最终一致性，那么必定会出现数据不一致的问题。这类问题大概率是因为消费者读取消息后，业务逻辑处理失败导致的。这时候可以增加重试机制。</p><p>重试分为同步重试和异步重试。</p><p>有些消息量比较小的业务场景，可以采用同步重试。在消费消息时如果处理失败，立刻重试 3-5 次，如果还是失败则写入到记录表中。</p><p>但如果消息量比较大，则不建议使用这种方式。因为如果出现网络异常，可能会导致大量的消息不断重试，影响消息读取速度造成消息堆积。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/14.jpg"><br>消息量比较大的业务场景，建议采用异步重试。在消费者处理失败之后，立刻写入重试表，有个 job 专门定时重试。</p><p>还有一种做法：如果消费失败，自己给同一个 topic 发一条消息。在后面的某个时间点，自己又会消费到那条消息，起到了重试的效果。如果对消息顺序要求不高的场景，可以使用这种方式。</p><h4 id="4-3-消息丢失问题"><a href="#4-3-消息丢失问题" class="headerlink" title="4.3 消息丢失问题"></a>4.3 消息丢失问题</h4><p>不管你是否承认，有时候消息真的会丢。即使这种概率非常小，也会对业务有影响。生产者、MQ 服务器、消费者都有可能会导致消息丢失的问题。为了解决这个问题，我们可以增加一张消息发送表。</p><p>当生产者发完消息之后，会往该表中写入一条数据，状态 status 标记为待确认；</p><p>如果消费者读取消息之后，调用生产者的 API 更新该消息的 status 为已确认；</p><p>有个 job 每隔一段时间检查一次消息发送表，如果5分钟（这个时间可以根据实际情况来定）后还有状态是待确认的消息，则认为该消息已经丢失了，重新发条消息。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/15.jpg"><br>这样不管是由于生产者、MQ 服务器、还是消费者导致的消息丢失问题，job 都会重新发消息。</p><h4 id="4-4-消息顺序问题"><a href="#4-4-消息顺序问题" class="headerlink" title="4.4 消息顺序问题"></a>4.4 消息顺序问题</h4><p>消息顺序问题是一种常见问题。我们以 Kafka 消费订单消息为例，订单有下单、支付、完成、退货等状态。这些状态是有先后顺序的，如果顺序错了会导致业务异常。<br>解决这类问题之前，我们需要先确认：消费者是否真的需要知道中间状态，只知道最终状态行不行？<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/16.jpg"><br>其实很多时候，我真的需要知道的是最终状态。这时可以把流程优化一下：<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/17.jpg"><br>这种方式可以解决大部分的消息顺序问题。</p><p>但如果真的有需要保证消息顺序的需求，那么可以将订单号路由到不同的 partition。同一个订单号的消息，每次到发到同一个 partition。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/18.jpg"></p><h4 id="4-5-消息堆积"><a href="#4-5-消息堆积" class="headerlink" title="4.5 消息堆积"></a>4.5 消息堆积</h4><p>如果消费者消费消息的速度小于生产者生产消息的速度，将会出现消息堆积问题。其实这类问题产生的原因很多。如果想要进一步了解，可以看看“我用kafka两年踩过的一些非比寻常的坑”。</p><p>那么消息堆积问题该如何解决呢？这个要看消息是否需要保证顺序。</p><p>如果不需要保证顺序，可以读取消息之后用多线程处理业务逻辑。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/19.jpg"></p><p>这样就能增加业务逻辑处理速度，解决消息堆积问题。但是线程池的核心线程数和最大线程数需要合理配置，不然可能会浪费系统资源。</p><p>如果需要保证顺序，可以读取消息之后将消息按照一定的规则分发到多个队列中，然后在队列中用单线程处理。<br><img src="https://myblog-1251991014.cos.ap-beijing.myqcloud.com/20.jpg"></p><blockquote><p>转载自：<a href="https://mp.weixin.qq.com/s/QGvzJCHFrnJU9Cf2eZZdxQ">https://mp.weixin.qq.com/s/QGvzJCHFrnJU9Cf2eZZdxQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 异步 </tag>
            
            <tag> 解耦 </tag>
            
            <tag> 削峰 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
